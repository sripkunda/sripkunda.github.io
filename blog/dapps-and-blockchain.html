<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dapps-and-blockchain</title>
    <link rel="shortcut icon" href="/assets/favicon.jpg" />
    <link rel="stylesheet" href="/css/md.css" />
    <link rel="stylesheet" href="/css/blog.css" />
    
    <!-- Math and Code -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/highlight.min.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" integrity="sha512-Fo3rlrZj/k7ujTnHg4CGR2D7kSs0v4LLanw2qksYuRlEzO+tcaEPQogQ0KaoGN26/zrn20ImR1DfuLWnOo7aBA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/js/all.min.js" integrity="sha512-fzff82+8pzHnwA1mQ0dzz9/E0B+ZRizq08yZfya66INZBz86qKTCt9MLU0NCNIgaMJCgeyhujhasnFUsYMsi0Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/a11y-dark.min.css">

    <!-- Startup Code -->
    <script>
    let headings = []; 
    let navHeadings = [];
    let content;
    let navBar; 
    
    function scrollBehavior(e) {
        navHeadings.forEach(e => e.node.className = "");
        let closest;
        if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight) {
            closest = navHeadings.length - 1;
        } else {
            const distances = Array.from(headings).map(e => Math.abs(e.getBoundingClientRect().top)); 
            closest = distances.indexOf(Math.min(...distances)); 
        }
        const parent = navHeadings[closest].parent; 
        const node = navHeadings[closest].node; 
        navHeadings.filter(e => e.parent == parent || e.parent == node).forEach(e => e.node.className = "open");
        navHeadings[closest].node.className = "selected open";
    }

    function load(e) {
        document.getElementById(window.location.hash?.substr(1))?.scrollIntoView();
        content = document.getElementById("blog_content");
        headings = content.querySelectorAll('h1, h2, h3');
        navBar = document.getElementsByTagName("nav")[0];
        const nav = document.getElementById("heading_tree");
        document.title = (headings[0].textContent || document.title).trim() + " | Sri Pranav Kunda";
        headings.forEach((h, i) => { 
            const node = h.cloneNode(true);
            const a = node.getElementsByTagName("a")[0];
            if (a) {
                const content = a.textContent; 
                a.remove(); 
                node.innerText = content;
            }
            nav.append(node);
            const getParent = (i) => {
                if (!navHeadings[i - 1]) return; 
                while (parseInt(navHeadings[i - 1]?.node.tagName[1]) >= parseInt(h.tagName[1])) {
                    i--; 
                }
                return navHeadings[i - 1]?.node;
            }
            navHeadings.push({ node: node, parent: getParent(i) });
            node.onclick = () => {
                headings[i].scrollIntoView({ behavior: 'smooth' });
            }
        });
        loadDropdowns();

        const isNotMarked = el => {
            while (el && el.parentNode && !el.parentNode.marked) {
            el = el.parentNode;
            if (el.marked) { return false }
            }
            return true;
        }
        [...document.querySelectorAll("p")]
            .filter(el => el.textContent.trim() === "" && isNotMarked(el) ? el.marked = true : false)
            .forEach(el => el.parentNode.removeChild(el));
    }

    const toggleMobileMenu = () => {
        navBar.style.display = navBar.style.display == "block" ? "" : "block";
    }

    const loadDropdowns = () => {
        Array.from(document.querySelectorAll("dropdown")).forEach(e => {
            const dropdown = document.createElement("div")
            dropdown.setAttribute("active", "");
            dropdown.className = "dropdown-banner";
            const inactiveBanner = `<h4 class="dropdown-label"><i class="dropdown-icon fa-solid fa-angle-right"></i> <span class="dropdown-text">${e.getAttribute("text")}</span></h4>`; 
            const activeBanner = `<h4 class="dropdown-label"><i class="dropdown-icon fa-solid fa-angle-down"></i> <span class="dropdown-text">${e.getAttribute("text")}</span></h4>`; 

            const activate = () => {
                dropdown.innerHTML = activeBanner
                div.className = "dropdown active"
                dropdown.setAttribute("active", true)
            }

            const deactivate = () => {
                dropdown.innerHTML = inactiveBanner
                div.className = "dropdown inactive"
                dropdown.setAttribute("active", "")
            }

            dropdown.onclick = () => {
                if (dropdown.getAttribute("active"))
                    deactivate()
                else
                    activate()
            }
            dropdown.innerHTML = inactiveBanner
            const div = document.createElement("div")
            e.parentNode.insertBefore(div, e)
            div.appendChild(dropdown)
            div.appendChild(e)
            const bInitActive = e.getAttribute("open") != null
            if (bInitActive) 
                activate() 
            else 
                deactivate()
            p = e.querySelector("p")
            p.style.marginTop = "2px";
        })
    }

    document.addEventListener("DOMContentLoaded", load);
    document.addEventListener("scroll", scrollBehavior);
</script>
</head>
<body>
    <div id="mobile_menu_button" onclick="toggleMobileMenu()">
        <i class="fas fa-bars"></i>
    </div>
    <nav>
    <h1 class="selected" onclick="window.location = '../'">Sri Pranav Kunda</h1>
    <span id="heading_tree">
    </span>
    <h1 onclick="window.scrollTo({ left: 0, top: 0, behavior: 'auto' })">Jump To Top</h1>
    <h1 onclick="window.scrollTo({ left: 0, top: document.body.scrollHeight, behavior: 'auto' })">Jump To Bottom</h1>
    </nav>
    <div id="blog_content">
        <h1>Decentralized Applications and Blockchain</h1><newline><p>This is an introduction to decentralized applications and blockchain, with an emphasis on Ethereum and Bitcoin. It includes an explanation of the primary concepts, mostly focusing on Ethereum's idea of a &quot;turing-complete programming language&quot; to offer a powerful platform for decentralized applications.</p><newline><blockquote><newline><p><strong>Important Note:</strong> A <strong>large</strong> amount of this information was directly interpreted from the <a href='https://ethereum.org/en/whitepaper/'>Ethereum Whitepaper</a>. Most of the methods discussed or implemented are <strong>not</strong> my own original ideas.</p><newline></blockquote><newline><h4>Introducing Blockchain Technology</h4><newline><p>In many computer applications, it is useful for the application's state to be nearly entirely independent of any single entity.</p><newline><p>What this means is that the application is not reliant on computer(s) owned by a single organization and is instead reliant on a network of <em>anyone's</em> computer(s). Computers in the network agree on the application's state in order for it to be valid, and anybody can join this network (with a catch, as you will see soon).</p><newline><p>This is the concept behind blockchain. A blockchain is a growing list of objects called blocks. Blocks are stored in order, where the <eq><span class='katex'><span class='katex-mathml'><math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>i</mi></mrow><annotation encoding='application/x-tex'>i</annotation></semantics></math></span><span class='katex-html' aria-hidden='true'><span class='base'><span class='strut' style='height:0.6595em;'></span><span class='mord mathnormal'>i</span></span></span></span></eq>th block references the <eq><span class='katex'><span class='katex-mathml'><math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mo stretchy='false'>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy='false'>)</mo></mrow><annotation encoding='application/x-tex'>(i - 1)</annotation></semantics></math></span><span class='katex-html' aria-hidden='true'><span class='base'><span class='strut' style='height:1em;vertical-align:-0.25em;'></span><span class='mopen'>(</span><span class='mord mathnormal'>i</span><span class='mspace' style='margin-right:0.2222em;'></span><span class='mbin'>−</span><span class='mspace' style='margin-right:0.2222em;'></span></span><span class='base'><span class='strut' style='height:1em;vertical-align:-0.25em;'></span><span class='mord'>1</span><span class='mclose'>)</span></span></span></span></eq>th block by it's hash.</p><newline><p>Assume that <eq><span class='katex'><span class='katex-mathml'><math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>n</mi></mrow><annotation encoding='application/x-tex'>n</annotation></semantics></math></span><span class='katex-html' aria-hidden='true'><span class='base'><span class='strut' style='height:0.4306em;'></span><span class='mord mathnormal'>n</span></span></span></span></eq> is the total number of blocks in the blockchain <eq><span class='katex'><span class='katex-mathml'><math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mo stretchy='false'>(</mo><mi>n</mi><mo>&gt;</mo><mn>1</mn><mo stretchy='false'>)</mo></mrow><annotation encoding='application/x-tex'>(n &gt; 1)</annotation></semantics></math></span><span class='katex-html' aria-hidden='true'><span class='base'><span class='strut' style='height:1em;vertical-align:-0.25em;'></span><span class='mopen'>(</span><span class='mord mathnormal'>n</span><span class='mspace' style='margin-right:0.2778em;'></span><span class='mrel'>&gt;</span><span class='mspace' style='margin-right:0.2778em;'></span></span><span class='base'><span class='strut' style='height:1em;vertical-align:-0.25em;'></span><span class='mord'>1</span><span class='mclose'>)</span></span></span></span></eq>. The first block is called the genesis block. If the data in the <eq><span class='katex'><span class='katex-mathml'><math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding='application/x-tex'>n - i</annotation></semantics></math></span><span class='katex-html' aria-hidden='true'><span class='base'><span class='strut' style='height:0.6667em;vertical-align:-0.0833em;'></span><span class='mord mathnormal'>n</span><span class='mspace' style='margin-right:0.2222em;'></span><span class='mbin'>−</span><span class='mspace' style='margin-right:0.2222em;'></span></span><span class='base'><span class='strut' style='height:0.6595em;'></span><span class='mord mathnormal'>i</span></span></span></span></eq>th block changes, where <eq><span class='katex'><span class='katex-mathml'><math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding='application/x-tex'>0 &lt; i &lt; n</annotation></semantics></math></span><span class='katex-html' aria-hidden='true'><span class='base'><span class='strut' style='height:0.6835em;vertical-align:-0.0391em;'></span><span class='mord'>0</span><span class='mspace' style='margin-right:0.2778em;'></span><span class='mrel'>&lt;</span><span class='mspace' style='margin-right:0.2778em;'></span></span><span class='base'><span class='strut' style='height:0.6986em;vertical-align:-0.0391em;'></span><span class='mord mathnormal'>i</span><span class='mspace' style='margin-right:0.2778em;'></span><span class='mrel'>&lt;</span><span class='mspace' style='margin-right:0.2778em;'></span></span><span class='base'><span class='strut' style='height:0.4306em;'></span><span class='mord mathnormal'>n</span></span></span></span></eq>, its hash also changes, effectively &quot;breaking&quot; the chain. Blocks <eq><span class='katex'><span class='katex-mathml'><math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn><mo separator='true'>,</mo><mo>…</mo><mo separator='true'>,</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding='application/x-tex'>n - 1, \dots, n - i + 1</annotation></semantics></math></span><span class='katex-html' aria-hidden='true'><span class='base'><span class='strut' style='height:0.6667em;vertical-align:-0.0833em;'></span><span class='mord mathnormal'>n</span><span class='mspace' style='margin-right:0.2222em;'></span><span class='mbin'>−</span><span class='mspace' style='margin-right:0.2222em;'></span></span><span class='base'><span class='strut' style='height:0.8389em;vertical-align:-0.1944em;'></span><span class='mord'>1</span><span class='mpunct'>,</span><span class='mspace' style='margin-right:0.1667em;'></span><span class='minner'>…</span><span class='mspace' style='margin-right:0.1667em;'></span><span class='mpunct'>,</span><span class='mspace' style='margin-right:0.1667em;'></span><span class='mord mathnormal'>n</span><span class='mspace' style='margin-right:0.2222em;'></span><span class='mbin'>−</span><span class='mspace' style='margin-right:0.2222em;'></span></span><span class='base'><span class='strut' style='height:0.7429em;vertical-align:-0.0833em;'></span><span class='mord mathnormal'>i</span><span class='mspace' style='margin-right:0.2222em;'></span><span class='mbin'>+</span><span class='mspace' style='margin-right:0.2222em;'></span></span><span class='base'><span class='strut' style='height:0.6444em;'></span><span class='mord'>1</span></span></span></span></eq> are now invalid as they no longer reference a valid block.</p><newline><p>If you feel unfamiliar with this concept, it might be useful to look into how <a href='https://en.wikipedia.org/wiki/Cryptographic_hash_function'>cryptographic hashes</a> work (remember that they are deterministic algorithms).</p><newline><h2 id='the-state-machine' tabindex='-1'><a class='header-anchor' href='#the-state-machine'><span>The State Machine</span></a></h2><newline><p>It is common to refer to the blockchain as an &quot;infinite state machine&quot; (technically, it is a <a href='https://en.wikipedia.org/wiki/Transition_system'>transition system</a>). There exists a state transition function <code>APPLY(S, TX) -&gt; S'</code>, where <code>S'</code> represents the state of the state machine after the execution of the function.</p><newline><ul><newline><li><code>S</code> represents the current state</li><newline><li><code>TX</code> represents the transactions that took place between <code>S</code> and the expected <code>S'</code></li><newline></ul><newline><p>Both Ethereum and Bitcoin implement the state machine in different ways according to their architecture.</p><newline><h3 id='an-overview' tabindex='-1'><a class='header-anchor' href='#an-overview'><span>An Overview</span></a></h3><newline><p><code>APPLY(S, TX)</code> generally does the following:</p><newline><ol><newline><li>Verify <code>TX</code>, usually by ensuring that the entity that made the transaction owns the money.</li><newline><li>Apply transaction fees, if applicable.</li><newline><li>Make requested changes (transfer currency, etc.)</li><newline><li>Give &quot;change&quot; (remaining money)</li><newline><li>Return <code>S'</code></li><newline></ol><newline><p>This is a very general representation of what both Bitcoin and Ethereum do in their state transition function. However, there are some key changes that we will explore below.</p><newline><h2 id='cryptocurrencies-and-architectures' tabindex='-1'><a class='header-anchor' href='#cryptocurrencies-and-architectures'><span>Cryptocurrencies and Architectures</span></a></h2><newline><p>There are different representations of the cryptocurrencies associated with these platforms for decentralized applications. Ethereum's and Bitcoin's are discussed below.</p><newline><blockquote><newline><p>Note that for now, the term &quot;decentralized application&quot; is just thrown around without a proper definition. We will discuss this more later on. For now, think of a decentralized application as a program that runs on a network of computers rather than on only one computer.</p><newline></blockquote><newline><h3 id='bitcoin's-unspent-transaction-outputs-(utxo)' tabindex='-1'><a class='header-anchor' href='#bitcoin's-unspent-transaction-outputs-(utxo)'><span>Bitcoin's Unspent Transaction Outputs (UTXO)</span></a></h3><newline><p>A large difference between the architectures of Ethereum and Bitcoin is the way digital currency is attributed to users. This major difference makes for some significant differences in the workings of each infrastructure's virtual machine.</p><newline><p>Although Bitcoin's protocols are outside of the scope of this writing, I feel that it is important to include to gain a better understanding of the state machine.</p><newline><p>UTXO stands for Unspent Transaction Output. As the name suggests, UTXO is the result of a transaction.</p><newline><p>Generally, Bitcoin users will use a wallet to manage funds. For every transaction, they will make a bitcoin &quot;address,&quot; a human-readable string which is referenced to claim ownership of the UTXO.</p><newline><p>The state in Bitcoin's state machine contains all existing bitcoins and their owning addresses. The input and output UTXO refer to the UTXO at <code>S</code> and <code>S'</code> respectively.</p><newline><p>This system is similar to how exchanges by cash work in real life. Assume there are two people, Person A and Person B. Person A has received 3 BTC, 2 BTC, 2 BTC, and 8 BTC, all from separate previous transactions. Person A wants to give 9 BTC to Person B. Then, instead of sending 9 BTC, the least possible BTC and UTXO that can be sent to minimize the change must be sent <strong>without splitting the UTXO</strong>.</p><newline><p>In this case, the best way is to send 8 BTC and 2 BTC (the input UTXO), a total of 10 BTC. The output UTXO are:</p><newline><ul><newline><li>9 BTC belonging to Person A</li><newline><li>1 BTC of change, belonging to Person B</li><newline></ul><newline><p>Note that the sum of all input UTXO must be greater than or equal to the sum of all output UTXO (<eq><span class='katex'><span class='katex-mathml'><math xmlns='http://www.w3.org/1998/Math/MathML'><semantics><mrow><mn>10</mn><mo>≥</mo><mo stretchy='false'>(</mo><mn>8</mn><mo>+</mo><mn>2</mn><mo stretchy='false'>)</mo></mrow><annotation encoding='application/x-tex'>10 \ge (8 + 2)</annotation></semantics></math></span><span class='katex-html' aria-hidden='true'><span class='base'><span class='strut' style='height:0.7804em;vertical-align:-0.136em;'></span><span class='mord'>10</span><span class='mspace' style='margin-right:0.2778em;'></span><span class='mrel'>≥</span><span class='mspace' style='margin-right:0.2778em;'></span></span><span class='base'><span class='strut' style='height:1em;vertical-align:-0.25em;'></span><span class='mopen'>(</span><span class='mord'>8</span><span class='mspace' style='margin-right:0.2222em;'></span><span class='mbin'>+</span><span class='mspace' style='margin-right:0.2222em;'></span></span><span class='base'><span class='strut' style='height:1em;vertical-align:-0.25em;'></span><span class='mord'>2</span><span class='mclose'>)</span></span></span></span></eq>). The reason why the sum can be greater is because transaction fees may exist to pay &quot;miners.&quot; This concept will be discussed later.</p><newline><p>UTXO must be sent as a whole and cannot be &quot;split&quot; or &quot;merged&quot; until ownership is verified (to prevent double payments). This is because the system by which UTXO is identified is its reference to the owner's Bitcoin address. If the BTC is not sent as a whole UTXO, the ownership cannot be verified.</p><newline><h3 id='ethereum's-account-system' tabindex='-1'><a class='header-anchor' href='#ethereum's-account-system'><span>Ethereum's Account System</span></a></h3><newline><p>Ethereum's accounts are a powerful alternative to UTXO in validating ownership of digital currencies and generalizing the idea of &quot;value&quot; and &quot;data&quot; to decentralized applications as well as users.</p><newline><p>More concretely, Ethereum's state consists of &quot;accounts&quot; made up of the following data:</p><newline><ul><newline><li>A nonce (a &quot;counter used to make sure each transaction can only be processed once,&quot; as stated exactly in the Ethereum whitepaper)</li><newline><li>The balance of the account in ETH (the native cryptocurrency of Ethereum)</li><newline><li>The contract code, for &quot;smart contracts&quot; (see below) and decentralized applications (not-required field)</li><newline><li>Persistent key-value storage</li><newline></ul><newline><p>Users can control their account using public key cryptography. The user receives a private (secret) key as well as a public key. Whenever a transaction is made, the user digitally signs the transaction, and the public key can be used later to validate if the signature made by the owner of the private key associated with that public key.</p><newline><p>Ethereum refers to these types of accounts as &quot;externally owned accounts.&quot;</p><newline><p>The other type of account is a &quot;contract account,&quot; which is essentially a piece of software that runs on the Ethereum Virtual Machine (dicussed later). I like to think of contracts as &quot;APIs&quot; that are invoked when a message is sent to them (or when you make an &quot;API call,&quot; to continue the analogy). Contracts can also access the persistent storage of their account. Throughout the article, these are referred to as &quot;smart contracts,&quot; or just &quot;contracts.&quot;</p><newline><h4>Transactions vs. Messages</h4><newline><p>In Ethereum, information is exchanged between accounts through data objects called messages. When externally owned accounts want to send information, they do so through a transaction.</p><newline><p>A transaction contains the following data:</p><newline><ul><newline><li>The receiver of the transaction</li><newline><li>The sender's digital signature</li><newline><li>The amount of ETH being transferred</li><newline><li>A limit on the number of &quot;computational steps&quot; that can be taken by this transaction, denoted <code>STARGTGAS</code></li><newline><li>The cost of each &quot;computational step,&quot; denoted <code>GASPRICE</code></li><newline><li>An arbitrary data field (not required)</li><newline></ul><newline><p>Note that transactions can be sent only by users. Let's understand what these fields represent. The first three are self-explanatory. For more information on the second field, take a look at <a href='https://en.wikipedia.org/wiki/Digital_signature'>digital signatures</a>.</p><newline><p>The last field, the data field, is generally not used, but smart contracts can read from data field to get some information. A good example might be to use the data field to pass parameters when invoking the smart contract.</p><newline><h4>Smart Contracts and Transaction Fees</h4><newline><p>Smart contracts, or more generally, decentralized applications, are the primary motivation for Ethereum's architecture. As we will look into soon, Ethereum has a turing-complete programming language that can be used to execute instructions on what is called the &quot;Ethereum Virtual Machine.&quot; A crucial issue with this (and possibly the reason why Bitcoin doesn't offer the same capabilities) is because it becomes difficult to stop abuse.</p><newline><p>Ethereum's solution to this is to impose costs on computational power. Computational steps are measured in what is called &quot;gas.&quot;</p><newline><p>In essence, the purpose of <code>STARGAS</code> and <code>GASPRICE</code> is to ensure that contracts cannot make infinite loops or run a ton of computational steps without paying some price. The <code>GASPRICE</code> represents the cost that the sender pays for every computational step.</p><newline><p>The gas price (transaction fee) is deducted from the sender of the transaction. Computations can only be done if there is enough gas remaining. Look <a href='https://ethereum.org/en/developers/docs/gas/'>here</a> for more information on how gas prices are calculated. The main concept here is that these transaction fees determined by the use of computational resources allow for a full-fledged development platform on Ethereum while also preventing abuse.</p><newline><h4>Messages</h4><newline><p>Although contracts cannot send transactions, they can communicate with other contracts by sending messages. Note that a transaction is also a &quot;type&quot; of message. A message contains the following:</p><newline><ul><newline><li>The sender of the message</li><newline><li>The receiver of the message</li><newline><li>Amount of ETH to transfer (added to the balance of the other contract)</li><newline><li><code>STARTGAS</code></li><newline><li>An arbitrary data field (not required)</li><newline></ul><newline><p>When a contract sends a message to another contract, the gas expended by the other contract is accounted into the transaction fee for the <strong>initial transaction</strong>, meaning that it is still billed from the externally owned account.</p><newline><h2 id='the-ethereum-virtual-machine-(evm)' tabindex='-1'><a class='header-anchor' href='#the-ethereum-virtual-machine-(evm)'><span>The Ethereum Virtual Machine (EVM)</span></a></h2><newline><p>The EVM is an execution environment for decentralized applications. Code executed on the EVM is called &quot;EVM Code.&quot; When executing contract code, data can be stored in the following ways:</p><newline><ul><newline><li>A stack (the data structure)</li><newline><li>A dynamically-sized byte array, called the &quot;memory&quot;</li><newline><li>A persistent key-value store.</li><newline></ul><newline><p>EVM Code is generally a low level language, somewhat resembling assembly language. It has its own &quot;instruction set&quot; for executing smart contract code. A good way to see this is to take a look at <a href='https://ethereum.org/en/developers/docs/evm/opcodes'>Ethereum's opcodes</a>.</p><newline><p>When code is executed, there is a program counter that is incremented for every instruction. When an instruction such as the <code>JUMP</code> instruction is executed, the program counter is set to whatever the operand is.</p><newline><p>When a program is executed on the EVM, the execution can be characterized by the following:</p><newline><ul><newline><li>Global State: the <code>S</code> that was discussed in the state machine, it contains all Ethereum accounts, their storage, and their balance</li><newline><li>Transaction: the transaction that invoked the execution of the program</li><newline><li>Message: the message that is causing the execution, if applicable</li><newline><li>Code: the EVM code to be executed</li><newline><li>Memory</li><newline><li>Stack</li><newline><li>Current (Remaining) Gas: the remaining gas, to monitor usage of computational power</li><newline></ul><newline><p>Most of the variables are self-explanatory, but you can learn more about the EVM <a href='https://ethereum.org/en/developers/docs/evm/'>here</a> or <a href='https://cypherpunks-core.github.io/ethereumbook/'>here</a>. Implementations of the EVM can be found in many programming languages.</p><newline><p>Ethereum code is executed as a part of the state transition function. A transaction is added to a block, the related EVM code is executed, and the block is validated.</p><newline><h4>The Merkle Tree</h4><newline><p>The Merkle (or hash) Tree is a common data structure used in cryptography. The concept is that the parent node is labeled with the hash of the labels of the child nodes, and the leaves connect to some data block (see the graphic below, from <a href='https://en.wikipedia.org/wiki/Merkle_tree'>wikipedia</a>)</p><newline><p><img src='https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hash_Tree.svg/465px-Hash_Tree.svg.png' alt='Merkle Tree'></p><newline><p>In Bitcoin, a Merkle tree is used to store information regarding the transactions. The reason why a merkle tree is used is to quickly validate information. The tree ensures that, even if the information regarding the transactions comes from different sources, all of the downloaded informatin is the same as long as the hashes match. If two bottom hashes do not create the hash of the top block, then it is apparent that there is an error and some sort of error exists in the data. This error could potentially be malicious, so the Merkle tree ensures the validity of the transaction information for each block in the blockchain throughout the entire network.</p><newline><p>Ethereum uses a variant of the Merkle tree, called the <a href='https://eth.wiki/fundamentals/patricia-tree'>Patricia Trie</a>. It is an extension of the radix trie, and it aims to solve the inefficiency of storing data in the trie.</p><newline><h2 id='consensus' tabindex='-1'><a class='header-anchor' href='#consensus'><span>Consensus</span></a></h2><newline><p>The aim of distributed applications is to manage it on a network of computers rather on just one computer. This section focuses strictly on consensus mechanisms. These are mechanisms that ensure a &quot;voting&quot; system, where all machines on the network vote for the true state of the application (or the blockchain). The majority vote is taken, so the application state is always determined by what the majority of the network wants.</p><newline><p>A general rule of thumb is that the more computers there are on the network, the more &quot;secure&quot; the application (and cryptocurrency) is. This is because it would take &quot;more votes&quot; to top the majority of the computers on the network.</p><newline><h4>Proof of Work (PoW) and &quot;Mining&quot;</h4><newline><p>Proof of Work is a concensus mechanism that relies on the computational power of computers on the network. In order for a new block to be created, each computer must solve a computational problem.</p><newline><p>This computational task is characteried by changing the content of a block so that its hash satisfies some requirement set (usually algorithmically, based on the number of computers in the network) by the network. Consider a hash function <code>hash(x)</code>, where <code>x</code> is the data in a block. The data in a block can be represented by a tuple of objects <code>b = (transactions, nonce, ..., prev_block_hash)</code>. Fix all fields except <code>nonce</code>.</p><newline><p>This field is a number. Changing the number changes the output of <code>hash(b)</code>. The computational problem to be solved is to ensure that <code>hash(b)</code> returns a value that meets some requirement, usually requiring a certain number of zeros at the beginning. For example, <code>000...</code> might be a valid hash, but <code>00H...</code> is not.</p><newline><p>This is a rather difficult task to complete, as it is usually done by trial and error. The process would take lots of computational power, but with so many computers it becomes plausible. The process of trying to guess the <code>nonce</code> field is called mining. The more comptuers there are on the network, the more zeros there are.</p><newline><p>We now explain why this works. Suppose a user wanted add a block with some information. The process of guessing this nonce is so difficult that it takes approximately a majority of the entire networks computing power to complete. This means that for anyone to add a block, they would need a huge amount of computing power that only grows according to the network's size.</p><newline><blockquote><newline><p>This is a clever way of preventing malicious actions, but it also comes with a large cost of resources (compute). Proof of Stake (PoS) is another method that some platforms have already adopted. It involves the staking of cryptocurrency to validate blocks. It is meant to be faster, more efficient, and more sustainable than PoW. <a href='https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/'>Ethereum plans to adopt PoS in the coming years</a>.</p><newline></blockquote><newline><h2 id='further-reading' tabindex='-1'><a class='header-anchor' href='#further-reading'><span>Further Reading</span></a></h2><newline><p>This was a general introduction to blockchain and decentralized applications, but there is much more to learn. Here are some resources worth looking at (that I've looked at myself):</p><newline><ul><newline><li><a href='https://cypherpunks-core.github.io/ethereumbook/'>More detail on Ethereum and Smart Contracts</a></li><newline><li>The <a href='https://ethereum.org/en/developers/docs/'>Etherereum Developer Documentation</a> have lots of details (both technical and non-technical)</li><newline><li>The <a href='https://en.bitcoin.it/wiki/Main_Page'>Bitcoin Wiki</a> offers some technical and non-technical documentation for Bitcoin. The more technical articles can be found <a href='https://en.bitcoin.it/wiki/Category:Technical'>here</a></li><newline><li>A full, up-to-date technical specification of Ethereum is the <a href='https://ethereum.github.io/yellowpaper/paper.pdf'>yellowpaper</a>.</li><newline></ul><newline><p>Last Updated: April 2022</p><newline>
    </div>
</body>
</html>
